---
title: 工厂模式
date: 2018-04-10 15:39:45
categories: "设计模式"
tags: "工厂模式"
---
## 简单工厂模式
简单工厂模式属于创建型模式，又叫静态工厂方法模式（Static Factory Method），  
但不属于GOF23种设计模式，简单工厂模式是由一个对工厂对象决定创建哪种类型的  
产品的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同  
工厂模式的一个特殊实现。

```java
/**
 * @className: Operation
 * @package: com.hh.designpattern.factory.simple
 * @describe: 抽象操作类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:06
 **/
public abstract class Operation {

    private double numberA;
    private double numberB;

    public double getNumberA() {
        return numberA;
    }

    public void setNumberA(double numberA) {
        this.numberA = numberA;
    }

    public double getNumberB() {
        return numberB;
    }

    public void setNumberB(double numberB) {
        this.numberB = numberB;
    }

    public abstract double getResult();

}

/**
 * @className: OperateAdd
 * @package: com.hh.designpattern.factory.simple
 * @describe: 加法类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:05
 **/
public class OperateAdd extends Operation {

    @Override
    public double getResult() {
        return getNumberA() + getNumberB();
    }
}

/**
 * @className: OperateDiv
 * @package: com.hh.designpattern.factory.simple
 * @describe: 除法类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:15
 **/
public class OperateDiv extends Operation {

    @Override
    public double getResult() {
        if (getNumberB() == 0) {
            throw new RuntimeException("divided by 0");
        }
        return getNumberA() / getNumberB();
    }

}

/**
 * @className: OperateMul
 * @package: com.hh.designpattern.factory.simple
 * @describe: 乘法类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:14
 **/
public class OperateMul extends Operation {

    @Override
    public double getResult() {
        return getNumberA() * getNumberB();
    }

}

/**
 * @className: OperateSub
 * @package: com.hh.designpattern.factory.simple
 * @describe: 减法类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:13
 **/
public class OperateSub extends Operation{

    @Override
    public double getResult() {
        return getNumberA() - getNumberB();
    }

}

/**
 * @className: OperationFactory
 * @package: com.hh.designpattern.factory.simple
 * @describe: 操作工厂类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:19
 **/
public class OperationFactory {

    public static Operation createOperation(char operator) {
        switch (operator) {
            case '+':
                return new OperateAdd();
            case '-':
                return new OperateSub();
            case '*':
                return new OperateMul();
            case '/':
                return new OperateDiv();
            default:
                throw new RuntimeException("unsupported operation");
        }
    }

}

/**
 * @className: Calculator
 * @package: com.hh.designpattern.factory.simple
 * @describe: 计算测试类
 * @auther: huanghai
 * @date: 2018/4/10 0010
 * @time: 上午 11:24
 **/
public class Calculator {

    public static void main(String[] args) {
        char operator = '*';
        Operation operation = OperationFactory.createOperation(operator);
        operation.setNumberA(1.2d);
        operation.setNumberB(3.4d);
        System.out.println(operation.getResult());
    }

}
```
>简单工厂模式的优缺点
* 优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。  
明确区分了各自的职责和权力，有利于整个软件体系结构的优化。
* 缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。
